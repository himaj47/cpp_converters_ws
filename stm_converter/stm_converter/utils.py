"""Utility functions for parsing and generating ROS 2 messages.

This module provides helper functions to:
    - Convert struct or header names into ROS 2 message names.
    - Parse `.msg` files into field specifications.
    - Handle namespace-qualified types.
    - Identify primitive and non-primitive ROS 2 message field types.
    - Assist in message generation workflows for auto-generated ROS interfaces.

It integrates with `rosidl_adapter` to parse existing `.msg` files and
handles recursive resolution of nested message fields.
"""

from rosidl_adapter.parser import MessageSpecification
from rosidl_adapter.parser import PRIMITIVE_TYPES, parse_message_file

import re

VECTOR_TYPE_PREFIX = "std::vector<"
VECTOR_TYPE_SUFFIX = ">"
STRUCT_NAME_SEPARATOR = "_"
DECLARATION_PREFIX = "_"
MESSAGE_FILE_EXTENSION = ".msg"
SCOPE_RESOLUTION_OPR = "::"
DEFAULT_INTERFACE_NAME = "enter_interface_name"

count = 0

def get_header_name(message_name: str):
    """Convert PascalCase message name into a snake_case header name.

    Example:
        >>> get_header_name("MyMessage")
        'my_message'

    Args:
        - ``message_name`` (str): The ROS message name in PascalCase.

    Returns:
        ``str``: The equivalent snake_case file name for the header.
    """

    header = re.sub(r"(?<!^)(?=[A-Z])", "_", message_name).lower()

    return header


def generate_msg_name(msg_name: str):
    """Convert snake case string to PascalCase ROS msg string.

    Example:
        >>> generate_msg_name("my_message")
        'MyMessage'
        >>> generate_msg_name("my_first_name")
        'MyFirstName'

    Args:
        - ``msg_name`` (str): Struct or type name.

    Returns:
        ``str``: PascalCase formatted name for `.msg` file naming.
    """

    processed_msg_name = ''

    if msg_name.find(STRUCT_NAME_SEPARATOR) != -1:
        split_msg = msg_name.split(STRUCT_NAME_SEPARATOR)

        for part in split_msg:
            if part:
                processed_msg_name += part.title()
            else:
                print("error: remove first or last underscore")
                return ''
    else:
        processed_msg_name += msg_name.title()

    return processed_msg_name


def remove_namespace(typename: str):
    """Remove namespace from a qualified C++ type.

    Example:
        >>> remove_namespace("ns::MyNum")
        ('ns', 'MyNum', 'MyNum')

    Args:
        - ``typename`` (str): namespaced C++ type.

    Returns:
        ``tuple[str, str, str]``: (namespace, generated_type, original_type)
    """

    namespace = ''
    type_ = ''
    generated_type = ''

    parts = typename.split(SCOPE_RESOLUTION_OPR)
    print(f"typename = {typename}")

    if len(parts) == 2:
        namespace = parts[0]
        type_ = parts[1]
        generated_type = generate_msg_name(parts[1])
    
    else:
        print("illegal use of '::' operator!!")

    return namespace, generated_type, type_


def get_msg_fields(msg: MessageSpecification):
    """Extract all fields from a ROS message specification.

    Args:
        - ``msg`` (MessageSpecification): Parsed message specification object.

    Returns:
        ``dict``: Mapping of field name to a list:
              [field_type, is_array, array_size, pkg_name, msg_fields]
    """

    all_fields = {}

    for field in msg.fields:
        all_fields[field.name] = [field.type.type, field.type.is_array, field.type.array_size, field.type.pkg_name]

        try:
            all_fields[field.name].append(field.msg_fields)

        except Exception as e:
            # TODO update msg_fields for complex types
            msg_fields = {}
            
            if field.type.type not in PRIMITIVE_TYPES:
                _, fields, _ = process_non_primitives(typename=field.type.type, is_array=field.type.is_array, pkg_name=field.type.pkg_name)
                msg_fields.update(fields)
                
            field.msg_fields = msg_fields
            all_fields[field.name].append(field.msg_fields)

    return all_fields


def get_fields(already_exists: bool, pkg_name: str, path:str , name: str):
    """Load message fields from an existing or newly generated ROS `msg`.

    Args:
        - ``already_exists`` (bool): Whether the `msg` already exists or autogenerated.
        - ``pkg_name`` (str): ROS package name.
        - ``path`` (str): Path to the ROS msg.
        - ``name`` (str): Message name without extension.

    Returns:
        ``dict``: Field mapping from `get_msg_fields`:
              [field_type, is_array, array_size, pkg_name, msg_fields]

    Raises:
        ``TypeError``: If the msg file cannot be parsed.
    """

    filename = ''
    if already_exists:
        filename += f"{path}/{pkg_name}/msg/{name}" + MESSAGE_FILE_EXTENSION
    else:
        filename += f"{path}/{name}" + MESSAGE_FILE_EXTENSION

    print(f"filename = {filename}")

    try:
        msg = parse_message_file(pkg_name=pkg_name, interface_filename=filename)
        fields = get_msg_fields(msg)
    except Exception as e:
        raise TypeError(f"exception: {e}\n filename = {filename}") 

    return fields

# don't need deps parameter anymore
def find_context_pkg(typename: str, header_name: str=None, pkg_name: str=DEFAULT_INTERFACE_NAME, deps: list=None, msg_interfaces=None, builtin_interfaces=None):
    """Find the ROS package where a message type is defined.

    Args:
        - ``typename`` (str): Message name without `.msg` extension.
        - ``header_name`` (str, optional): Unused; reserved for future.
        - ``pkg_name`` (str, optional): Current package name.
        - ``deps`` (list, optional): Unused; reserved for future.
        - ``msg_interfaces`` (dict): Mapping of package -> list of defined types from dependencies.
        - ``builtin_interfaces`` (dict): Mapping of builtin packages that generate interfaces -> path to interface.

    Returns:
        -  ``tuple[str, str, bool]``: (context_pkg of typename, path to msg file, already_exists)

    Raises:
        ``NameError``: If the message type is not found in dependencies.
    """

    # TODO: remove context_pkg -> no need, now checks from the dependencies
    context_pkg = ''
    pathToFile = ''
    already_exists = False

    is_present = False
    # all builtin and generated msgs
    for package, types in msg_interfaces.items():
        if 'msg/' + typename in types:
            is_present = True
            context_pkg += package
            pathToFile += builtin_interfaces[context_pkg] + f"/share/{context_pkg}/msg"
            break
    
    if not is_present:
        raise NameError(f"{typename}.msg doesn't exists!! check dependencies")

    return context_pkg, pathToFile, already_exists


def check_if_primitve(typename: str):
    """Check and return the canonical ROS primitive type for a given type name.

    Args:
        - ``typename`` (str): Type name to check.

    Returns:
        ``str``: Canonical primitive type name if matched, else empty string.
    """

    field_type = ''

    if typename in PRIMITIVE_TYPES: 
        field_type += typename

    elif typename == "double":
        field_type += "float32"

    elif typename == "u16string" or typename == "u32string":
        field_type += "wstring"

    elif typename + '32' in PRIMITIVE_TYPES:
        field_type += typename + '32'

    elif typename[-1] == 't' and typename[-2] == '_':
        type = typename.strip("_t")
        if type in PRIMITIVE_TYPES:
            field_type += type

    return field_type

# don't need deps parameter anymore
def process_non_primitives(typename: str, is_array=False, pkg_name:str =DEFAULT_INTERFACE_NAME, deps: list=None, msg_interfaces=None, builtin_interfaces=None):
    """Resolve a non-primitive type into its message context and fields.

    Args:
        - ``typename`` (str): Field type name.
        - ``is_array`` (bool): Whether the field is an array.
        - ``pkg_name`` (str): Current package name.
        - ``deps`` (list, optional): Unused; reserved for future.
        - ``msg_interfaces`` (dict): Mapping of package -> list of defined types from dependencies.
        - ``builtin_interfaces`` (dict): Mapping of builtin packages that generate interfaces -> path to interface.

    Returns:
        - ``tuple[str, dict, str]``:
            - ``context_pkg`` (str): Package where the type is defined.
            - ``msg_fields`` (dict): Nested message fields.
            - ``field_type`` (str): Resolved ROS type name.
    """

    field_type = ''
    context_pkg = ''
    msg_fields = {}

    field_type += check_if_primitve(typename)

    if not field_type:
        field_type += typename

        # assuming namespace typed struct
        if field_type.find(SCOPE_RESOLUTION_OPR) != -1:
            namespace, field_type, typename = remove_namespace(field_type) 

            type_ = check_if_primitve(typename)
            # raise TypeError(f"field_type = {field_type} and type_ = {type_}")
            if type_:
                if is_array: type_ += "[]"
                return context_pkg, msg_fields, type_

        # don't need deps parameter anymore
        pkg, path, already_exists = find_context_pkg(field_type, typename, pkg_name, deps, msg_interfaces, builtin_interfaces)
        context_pkg += pkg
        msg_fields = get_fields(already_exists=already_exists, pkg_name=context_pkg, path=path, name=field_type)

    if is_array: field_type += "[]"

    return context_pkg, msg_fields, field_type